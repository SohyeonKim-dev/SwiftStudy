import Swift

// 함수 : 이름이 있는 클로저
// 클로저 : 코드의 블록, 1급 객체 함수, 전달인자, 변수, 상수 등등 가능


/*
 
{ (매개변수 목록) -> 반환타입 in
    실행 코드
}

 저 매개변수 부분과 실행 코드를 구분 짓는 것이 in 이라는 키워드이다!
 
*/




/*
 
 // sum 이라는 상수에 클로저를 할당
 // let sum : type = 값 의 형태로 파악!

let sum: (Int, Int) -> Int = { (a: Int, b: Int) in
    return a + b
}

let sumResult: Int = sum(1, 2)
print(sumResult)

*/



/* 선언과 정의가 분리
 
 let add: (Int, Int) -> Int
 add = { (a: Int, b: Int) in
     return a + b
 }

 let substract: (Int, Int) -> Int
 substract = { (a: Int, b: Int) in
     return a - b
 }

 let divide: (Int, Int) -> Int
 divide = { (a: Int, b: Int) in
     return a / b
 }

 
 func calculate(a: Int, b: Int, method: (Int, Int) -> Int) -> Int {
     return method(a, b)
 }
 

 var calculated: Int
 calculated = calculate(a: 50, b: 10, method: add)
 print(calculated) // 60

 calculated = calculate(a: 50, b: 10, method: substract)
 print(calculated) // 40

 calculated = calculate(a: 50, b: 10, method: divide)
 print(calculated) // 5

 
 //따로 클로저를 상수/변수에 넣어 전달하지 않고, 함수를 호출할 때 클로저를 작성하여 전달할 수도 있습니다.

 calculated = calculate(a: 50, b: 10, method: { (left: Int, right: Int) -> Int in
     return left * right
 })

 print(calculated) // 500
 // 이게 당최 무엇,,?
 
 */



/*
 
 1. 후행 클로저
: 클로저가 함수의 마지막 전달인자 then, 마지막 매개변수 이름 (method)을 생략한 후
 함수 소괄호 외부에 클로저를 구현할 수 있습니다.

 result = calculate(a: 10, b: 10) { (left: Int, right: Int) -> Int in
     return left + right
 }

 
 2. 반환타입 생략

 calculate(a:b:method:) 함수의 method 매개변수는
 Int 타입을 반환할 것이라는 사실을 컴파일러도 알기 때문에 (why? -> add, divide 이런 애들 정의로 인해서?)
 굳이 클로저에서 반환타입을 명시해 주지 않아도 됩니다.
 + 대신 in 키워드는 생략할 수 없습니다

 
 result = calculate(a: 10, b: 10, method: { (left: Int, right: Int) in
     return left + right
 })

 
 // 후행클로저와 함께 사용할 수도 있습니다 -> 더 간략화
 result = calculate(a: 10, b: 10) { (left: Int, right: Int) in
     return left + right
 }

 
 3. 단축 인자이름

 클로저의 매개변수 이름이 굳이 불필요하다면 단축 인자이름을 활용할 수 있습니다.
 단축 인자이름은 클로저의 매개변수의 순서대로 $0, $1, $2... 처럼 표현합니다.

 result = calculate(a: 10, b: 10, method: {
     return $0 + $1
 })


 // 당연히 후행 클로저와 함께 사용할 수 있습니다 wow
 result = calculate(a: 10, b: 10) {
     return $0 + $1
 }
 
 
 4. 암시적 반환 표현

 클로저가 반환하는 값이 있다면 클로저의 마지막 줄의 결과값은 암시적으로 반환값으로 취급합니다.
 -> return 을 안 써도 된다.

 result = calculate(a: 10, b: 10) {
     $0 + $1
 }

 // 간결하게 한 줄로 표현
 result = calculate(a: 10, b: 10) { $0 + $1 }

 
 
 축약 전과 후 비교

 //축약 전
 result = calculate(a: 10, b: 10, method: { (left: Int, right: Int) -> Int in
     return left + right
 })

 //축약 후
 result = calculate(a: 10, b: 10) { $0 + $1 }
 
 : 과도한 축약은 코드 가독성을 해치므로 지양하자. 
 
 */
